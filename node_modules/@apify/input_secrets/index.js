"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  decryptInputSecrets: () => decryptInputSecrets,
  encryptInputSecretValue: () => encryptInputSecretValue,
  encryptInputSecrets: () => encryptInputSecrets,
  getInputSchemaSecretFieldKeys: () => getInputSchemaSecretFieldKeys
});
module.exports = __toCommonJS(src_exports);

// src/input_secrets.ts
var import_ow = __toESM(require("ow"));
var import_crypto = require("crypto");
var import_utilities = require("@apify/utilities");
var BASE64_REGEXP = /[-A-Za-z0-9+/]*={0,3}/;
var ENCRYPTED_INPUT_VALUE_PREFIX = "ENCRYPTED_VALUE";
var ENCRYPTED_INPUT_VALUE_REGEXP = new RegExp(`^${ENCRYPTED_INPUT_VALUE_PREFIX}:(${BASE64_REGEXP.source}):(${BASE64_REGEXP.source})$`);
function getInputSchemaSecretFieldKeys(inputSchema) {
  return Object.keys(inputSchema.properties).filter((key) => !!inputSchema.properties[key].isSecret);
}
__name(getInputSchemaSecretFieldKeys, "getInputSchemaSecretFieldKeys");
function encryptInputSecretValue({ value, publicKey }) {
  (0, import_ow.default)(value, import_ow.default.string);
  (0, import_ow.default)(publicKey, import_ow.default.object.instanceOf(import_crypto.KeyObject));
  const { encryptedValue, encryptedPassword } = (0, import_utilities.publicEncrypt)({ value, publicKey });
  return `${ENCRYPTED_INPUT_VALUE_PREFIX}:${encryptedPassword}:${encryptedValue}`;
}
__name(encryptInputSecretValue, "encryptInputSecretValue");
function encryptInputSecrets({ input, inputSchema, publicKey }) {
  (0, import_ow.default)(input, import_ow.default.object);
  (0, import_ow.default)(inputSchema, import_ow.default.object);
  (0, import_ow.default)(publicKey, import_ow.default.object.instanceOf(import_crypto.KeyObject));
  const secretsInInputKeys = getInputSchemaSecretFieldKeys(inputSchema);
  if (secretsInInputKeys.length === 0)
    return input;
  const encryptedInput = {};
  for (const key of secretsInInputKeys) {
    const value = input[key];
    if (value && import_ow.default.isValid(value, import_ow.default.string) && !ENCRYPTED_INPUT_VALUE_REGEXP.test(value)) {
      encryptedInput[key] = encryptInputSecretValue({ value: input[key], publicKey });
    }
  }
  return { ...input, ...encryptedInput };
}
__name(encryptInputSecrets, "encryptInputSecrets");
function decryptInputSecrets({ input, privateKey }) {
  (0, import_ow.default)(input, import_ow.default.object);
  (0, import_ow.default)(privateKey, import_ow.default.object.instanceOf(import_crypto.KeyObject));
  const decryptedInput = {};
  for (const [key, value] of Object.entries(input)) {
    if (import_ow.default.isValid(value, import_ow.default.string) && ENCRYPTED_INPUT_VALUE_REGEXP.test(value)) {
      const match = value.match(ENCRYPTED_INPUT_VALUE_REGEXP);
      if (!match)
        continue;
      const [, encryptedPassword, encryptedValue] = match;
      try {
        decryptedInput[key] = (0, import_utilities.privateDecrypt)({ privateKey, encryptedPassword, encryptedValue });
      } catch (err) {
        throw new Error(`The input field "${key}" could not be decrypted. Try updating the field's value in the input editor. Decryption error: ${err}`);
      }
    }
  }
  return { ...input, ...decryptedInput };
}
__name(decryptInputSecrets, "decryptInputSecrets");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  decryptInputSecrets,
  encryptInputSecretValue,
  encryptInputSecrets,
  getInputSchemaSecretFieldKeys
});
//# sourceMappingURL=index.js.map